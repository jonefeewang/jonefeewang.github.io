<!DOCTYPE html><html lang="zh-CN"><head><meta name="google-site-verification" content="IqPxX6jMzoqSIvuvpvuP9PCF7niBjR9EBY0UfP9MHEU"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="王军飞的博客"><title>时间轮算法分析和应用 | 王军飞的随笔</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">时间轮算法分析和应用</h1><a id="logo" href="/.">王军飞的随笔</a><p class="description">always be the best</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">时间轮算法分析和应用</h1><div class="post-meta">2023-04-10<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 4.3k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 15</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" href="/2023/04/10/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E7%94%A8/#vcomment"><span class="valine-comment-count" data-xid="/2023/04/10/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E7%94%A8/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%A1%881-%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8"><span class="toc-number">2.1.</span> <span class="toc-text">方案1: 无序列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%A1%882-%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8"><span class="toc-number">2.2.</span> <span class="toc-text">方案2: 有序列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%A1%883-%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">方案3: 树形结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%A1%884-%E7%AE%80%E5%8D%95%E6%97%B6%E9%97%B4%E8%BD%AE"><span class="toc-number">2.4.</span> <span class="toc-text">方案4: 简单时间轮</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%A1%885-hash%E6%9C%89%E5%BA%8F%E6%97%B6%E9%97%B4%E8%BD%AE"><span class="toc-number">2.5.</span> <span class="toc-text">方案5: hash有序时间轮</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%A1%886-hash%E6%97%A0%E5%BA%8F%E6%97%B6%E9%97%B4%E8%BD%AE"><span class="toc-number">2.6.</span> <span class="toc-text">方案6: hash无序时间轮</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%A1%887-%E5%A4%9A%E7%BA%A7%E6%97%B6%E9%97%B4%E8%BD%AE"><span class="toc-number">2.7.</span> <span class="toc-text">方案7: 多级时间轮</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">java中的几种实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-Timer"><span class="toc-number">4.0.1.</span> <span class="toc-text">java Timer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-ScheduledThreadPoolExecutor"><span class="toc-number">4.0.2.</span> <span class="toc-text">java ScheduledThreadPoolExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty%E6%97%B6%E9%97%B4%E8%BD%AEio-netty-util-HashedWheelTimer"><span class="toc-number">4.0.3.</span> <span class="toc-text">Netty时间轮io.netty.util.HashedWheelTimer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kafka%E5%86%85%E7%BD%AE%E7%9A%84%E6%97%B6%E9%97%B4%E8%BD%AE"><span class="toc-number">4.0.4.</span> <span class="toc-text">Kafka内置的时间轮</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>时间轮是一个比较有趣的算法，他最早刊登在George Varghese和Tony Lauck的论文里。</p>
<p>问题的初衷是如何实现一个高效的定时器调度。比如有很多定时任务，每个任务的定时时间不一样，有1s 后，5s 后，1小时后，3天后，假设有很多个这样的任务，数千个或数万个，怎么通过程序来实现高效的调度每个任务，让他们在到期后顺利执行。</p>
<p>java中最直接的就是使用Timer类，使用 add方法增加一个定时任务。但是这种方法有几个问题:</p>
<ol>
<li>定时任务需要Timer内的线程来执行，一个Timer在背后只有一个线程在执行，假设其中一个任务本身的执行时间太久，后边的任务就会被耽搁，特别是当有很多任务，比如成千上万个需要调度时</li>
<li>而且这个类还有一个问题，如果其中一个TimerTask在执行时抛出了异常，那么整个计时器会停止运行。</li>
</ol>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>下边来看看论文里讲的几种实现方法</p>
<p>总结一下，整个任务调度算法分为4种操作：</p>
<ol>
<li>创建一个任务(start_timer)</li>
<li>取消一个任务(stop_timer)</li>
<li>时钟走一格，需要做的操作(per_tick_bookkeeping)</li>
<li>启动到期的任务 (expire_process)</li>
</ol>
<h2 id="方案1-无序列表"><a href="#方案1-无序列表" class="headerlink" title="方案1: 无序列表"></a>方案1: 无序列表</h2><p>假设有一个列表，每个元素存储一个任务，任务包含任务到期后要做的操作，以及任务的到期时间。<br>这时，我们通过程序模拟时钟在走动(tick)，比如, 14:20:21, 14:20:22,  。。。按顺序推动时间走，时间每走一格，上边4个操作需要的时间复杂度如下:</p>
<ul>
<li>开始调度一个任务(start_timer): 来了一个新的任务，我们把任务直接插入到列表尾部，时间复杂度O(1)，每次插入后返回任务的指向指针，这样在取消任务时，就可以直接拿来操作。</li>
<li>取消一个任务(stop_timer):  如上，我们持有任务的指针， 假设我们使用双向链表来实现列表，直接操作指针即可完成。</li>
<li>时钟走一格，需要做的操作(per_tick_bookkeeping)：因为整个列表里，每个任务的过期时间不一样，我们需要遍历整个列表，找到当前这一时间格时，过期里边所有任务。所以时间复杂度度是O(n)</li>
<li>启动到期的任务 (expire_process)：这个操作只要找到过期的任务，直接操作即可，不需要额外的时间处理。</li>
</ul>
<p>因为取消一个任务，启动到期任务两个操作，只要我们保存任务的指针，即可完成，时间复杂度都是O(1)，因此后续的方案都不再赘述他们。</p>
<h2 id="方案2-有序列表"><a href="#方案2-有序列表" class="headerlink" title="方案2: 有序列表"></a>方案2: 有序列表</h2><p>将列表维护为一个有序列表，把任务按照时间到期的顺序做排序，最早到期的任务排在最前面。<br>这样，算法的操作如下:</p>
<ul>
<li>开始调度一个任务(start_timer): 来一个新的调度任务时，需要将任务插入到有序列表相应的位置，按照过期时间排序，最坏时间复杂度是O(n)。</li>
<li>时钟走一格，需要做的操作(per_tick_bookkeeping)：直接从列表开头开始找任务，和当前时间做比较，因为最先到期的都在列表开头，因此时间复杂度基本是常数，是O(1)的时间复杂度。</li>
</ul>
<h2 id="方案3-树形结构"><a href="#方案3-树形结构" class="headerlink" title="方案3: 树形结构"></a>方案3: 树形结构</h2><p>将列表维护为一个非平衡二叉树，堆或者前序、或后序遍历树，这种情况下，插入一个任务的时间复杂度可以降低到O(logn)</p>
<h2 id="方案4-简单时间轮"><a href="#方案4-简单时间轮" class="headerlink" title="方案4: 简单时间轮"></a>方案4: 简单时间轮</h2><p>时间轮方式。将所有任务的换算为多少秒或毫秒(Interval)后到期，维护一个最大过期值(Interval)长度的数组。比如有10个任务，分别是1s，3s，100s 后到期，就建一个100长度的数组，数组的index就是每个任务的过期值(Interval)，当前时间作为第一个元素，那么第二个元素就是1s 后到期的任务，第三个是2s 后到期的任务，依次类推。当前时间随着时钟的前进(tick)，逐步发现过期的任务。<br><img src="/2023/04/10/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E7%94%A8/timing_wheel.png"></p>
<p>这种方案的时间复杂度:</p>
<ul>
<li>开始调度一个任务(start_timer): 来一个新的调度任务时，换算任务的到期时间为到期值(Interval)，直接放入相应的数组元素内即可，时间复杂度是O(1)。</li>
<li>时钟走一格，需要做的操作(per_tick_bookkeeping)：时钟走一格直接拿出这一格内的任务执行即可，时间复杂度是O(1)。</li>
</ul>
<h2 id="方案5-hash有序时间轮"><a href="#方案5-hash有序时间轮" class="headerlink" title="方案5: hash有序时间轮"></a>方案5: hash有序时间轮</h2><p>方案4虽然很完美，所有的操作时间复杂度都是O(1)，但是当任务最大到期时间值非常大时，比如100w个时，构建这样一个数组是非常耗费内存的。可以改进一下，仍然使用时间轮，但是是用hash的方式将所有任务放到一定大小的数组内。 这个数组长度可以想象为时间轮的格子数量，轮盘大小(W)。</p>
<p>hash的数值仍然是每个任务的到期值(Interval)，最简单的是轮盘大小(W)取值为2的幂次方，Interval哈希W后取余，余数作为轮盘数组的index，数组每个元素可能会有多个任务，把这些任务按照过期的绝对时间排序，如方案二一样，最先过期的排在最前面，这样就形成了一个链表，或者叫做时间轮上的一个桶。<br><img src="/2023/04/10/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E7%94%A8/timing_wheel_sorted.png"><br>这种方案的时间复杂度：</p>
<ul>
<li>开始调度一个任务(start_timer): 来一个新的调度任务时，换算任务的到期时间为到期值(Interval)，hash 一下时间轮的轮盘大小，放置在余数为index的格子内，同时需要放置有序列表合适的位置上，这样最坏的时间复杂度为O(n)(放置的位置刚好在列表最后的一个元素)，最好的时间复杂度为O(1)(放置的位置在列表的第一个位置)。平均时间复杂度为O(1)，当轮盘大小(W) &gt; 所有任务的个数n时，并且hash函数能将所有任务均匀的分布在每个数组内。</li>
<li>时钟走一格，需要做的操作(per_tick_bookkeeping)：时钟走一格直接拿出这一格内的任务列表，从列表开头开始拿出任务过期时间的绝对值和当前时间做对比，过期的直接拿出，触发过期操作。</li>
</ul>
<h2 id="方案6-hash无序时间轮"><a href="#方案6-hash无序时间轮" class="headerlink" title="方案6: hash无序时间轮"></a>方案6: hash无序时间轮</h2><p>因为方案5在执行添加任务时，需要和hash 在同一时间格子内的有序任务列表内的元素做比较，放在合适的位置上，最坏时间复杂度是O(n)。如果要摆脱这个问题，需要可以将数组元素内的列表作为无序列表。<br>开始调度一个任务(start_timer): 来一个新的调度任务时，换算任务的到期时间为到期值(Interval)，hash 一下时间轮的轮盘大小，放置在余数为index的格子内，商值保存在任务内，因为余数数组元素内的列表是无序数组，直接放置在末尾即可，时间复杂度是O(1)。<br>时钟走一格，需要做的操作(per_tick_bookkeeping)：时钟走一格直接拿出这一格内的任务列表，从列表开头开始，逐个检查列表内的元素，如果商值为0，则直接过期数组，如果非0，则需要做减一操作，等待下一个时钟周期。这里的最坏时间复杂度为O(n)，因为需要遍历列表内的每一个元素。平均时间复杂度是O(1)，当轮盘大小(W) &gt; 所有任务的个数n时，并且hash函数能将所有任务均匀的分布在每个数组元素内。<br><img src="/2023/04/10/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E7%94%A8/timing_wheel_unsorted.png"></p>
<h2 id="方案7-多级时间轮"><a href="#方案7-多级时间轮" class="headerlink" title="方案7: 多级时间轮"></a>方案7: 多级时间轮</h2><p>这个方案是直接模拟时钟，将天、小时、分钟、秒作为4个不同的时间轮，每个时间轮都有一个单独的数组，来模拟时间轮盘。</p>
<p>注意，这个方案的核心思想是将最大过期时间值Max(Interval)按级别，分散在不同的时间轮内来标识，以此来用比较少的数组元素来表示最大值Max(Interval)的过期时间。秒级时间轮转一圈刚好是1分钟，分钟级时间轮转一圈是一小时，小时级时间轮转一圈是一天，天级时间轮转一圈可以是100天或1年，轮盘大小可以根据需要承接的最大时间段来确定。比如天级轮盘大小设置为100，小时级设置未24消息，分钟、秒级都设置为60个，那么可以承接的最大过期时间值Max(Interval)(每级轮盘不超额放置)将是100*24*60*60=864万，而实际底层存储我们只使用了100+24+60+60=244大小的数组。</p>
<p>时间轮驱动是由最小级开始的，秒级时间轮转一圈，分钟级时间轮转一个格子。分钟级时间轮转一圈，小时级时间轮转一个格子，小时级时间轮转一圈，天级时间轮转一个格子。假设一个任务的过期时间是3天，10小时，15分，10秒。那么天级时间轮也是拿时间段来hash轮盘大小，比如 hash 完是3那么就放到第3个格子，小时级时间轮同样的做hash余数作为数组的index，放置到相应的格子内，依次类推。当天级时间轮，过期一个时间时，需要将任务踢到下级时间轮，看是否在下级时间轮的范围时间内，如果能放进去，则继续用下级时间轮来推动，否则再继续往下级时间轮来踢，如果所有的时间轮都无法承接这个过期任务了，那么就启动定时任务。还拿这个任务来做例子，如果天级时间轮发下，3天已经过完了，就会把这个任务踢到小时级时间轮，小时级时间轮发现10小时、15分、10秒在自己可以承担的时间范围内，则放到相应的格子内。10小时过完以后，小时级时间轮又会把这个任务踢到分钟级，分钟级过完后，又会踢到秒级，秒级过完后，发现已没有更下级时间轮了，就直接启动定时任务。<br><img src="/2023/04/10/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E7%94%A8/timing_wheel_hiatarch.png"><br>这种方案的时间复杂度：</p>
<ul>
<li>开始调度一个任务(start_timer): 来一个新的调度任务时，换算任务的每个级别，天、小时、分、秒的到期时间为到期值(Interval)，hash 一下时间轮的轮盘大小，放置在余数为index的格子内，时间复杂度是O(1)。</li>
<li>时钟走一格，需要做的操作(per_tick_bookkeeping)：时钟走一格直接拿出这一格内的任务列表，从列表开头开始，逐个检查列表内的元素，检查任务是否还有下级时间轮，没有的话直接过期任务，有的话踢到下级时间轮内，比如某个任务的过期时间是3min50后，那么个任务会存储在分钟时间轮3那个桶里，当这个桶过期后，查看剩余的时间是否能放到下一级时间轮，发现剩余50min 就将任务放到秒级时间轮的50那个桶里，等待过期；并且这个方案的平均时间复杂度是O(1)，前提是当轮盘大小(W) &gt; 所有任务的个数n时，并且hash函数能将所有任务均匀的分布在每个数组元素内。</li>
</ul>
<blockquote>
<p>注意：在n&lt;W时，即过期任务个数小于轮盘大小W时，方案6、7的平均时间复杂度都是O(1)，但是在时钟每走一格，需要做的操作里(per_tick_bookkeeping)，方案6和方案7会有一些细小的区别，会影响到方案选择：</p>
<p>设T为所有过期任务的平均时长跨度(开始到结束的时间间隔)<br>设M为所有数组的元素个数总和，即时间轮大小<br>设m 为多层时间轮的层数</p>
<p>那么方案6里，每个任务的总用时间为：<br>c(6)*T/M<br>c(6)是时钟每走一格，需要将任务递减1需要的用时。如果任务需要递减T/M次，那么任务的总用时就是c(6)*T/M。</p>
<p>相对于方案7，每个任务的总用时间为:<br>c(7)*m<br>c(7)是踢到下一级时间轮的用时，m 是时间轮的最大层级，所以每个任务的总用时即c(7)*m</p>
<p>如果有 n 个定时任务，那么每个时间单位内的任务的用时是:<br>方案6是:   n*c(6)/M<br>方案7是:   n*c(7)*m/T</p>
<p>因为c(6),c(7)两项的用时基本是常数，m值也不会很大(因为层级不可能很多)，这样一比较就会发现，虽然方案6、方案7的start timer都一样，时间复杂度都是O(1)，但(per_tick_bookkeeping)还是有差别的(虽然平均时间复杂度都是O(1))，根据上边的公式，如果M大那么应该选方案6(除数大)，如果T大应该选方案7。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综合比较一下上述的5个方案:</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>start_timer</th>
<th>stop_timer</th>
<th>per_tick_bookkeeping</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>方案1：无序列表</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
<td></td>
</tr>
<tr>
<td>方案2：有序列表</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>方案3：树、堆结构列表</td>
<td>O(log(n))</td>
<td>O(1)</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>方案4：简单时间轮	O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>当时间跨度很大时，比较耗内存。</td>
<td></td>
</tr>
<tr>
<td>方案5：hash 有序桶时间轮</td>
<td>O(n)最坏情况</td>
<td>O(1)平均时间复杂度</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>方案6：hash无序桶时间轮</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)最坏情况  O(1)平均时间复杂度</td>
<td>[1]*</td>
</tr>
<tr>
<td>方案7：多层时间轮	O(m)</td>
<td>O(1)</td>
<td>O(1)平均时间复杂度</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>[1]*per_tick_bookkeeping占用时间:     时间轮轮盘比较大时选择方案6，任务的平均过期时间长度比较长时选择方案7</p>
<p>比较上边几个方案，从时间复杂度来看，最好选择方案5、6、7。但是方案5在创建一个调度任务时，会有最坏的时间复杂度O(n)。在方案6和方案7之间作比较，在设定比较大的轮盘值W时(W&gt;n)，并且任务均匀的散列到每个桶内时，都会有一个比较好的最好时间复杂度O(1)，但是对于时间跨度比较大的情况(T&gt;W)时，选择方案7会比较好，在时间跨度比较小(T&lt;W)时，选择方案6会稍微好一些。</p>
<p>举个例子，对于最高峰值10000 qps的服务，检查每个请求是否在2s内过期，设定tick为1ms，T 的最大值为2000(ms)，相对于方案7中的例子，时间跨度并不是很大，在选择轮盘大小时，我们甚至可以设置W为2048，依据上边的公式比较，所以选择方案6 会更合适。实际在现实例子中，使用时间轮来调度定时任务时，时间跨度都不会很大因此T一般都会小于W，所以方案6在绝大多数场景下都适用。</p>
<h1 id="java中的几种实现"><a href="#java中的几种实现" class="headerlink" title="java中的几种实现"></a>java中的几种实现</h1><p>下面来看下几种典型的定时调度算法实现 :</p>
<h3 id="java-Timer"><a href="#java-Timer" class="headerlink" title="java Timer"></a>java Timer</h3><p>这是java库里最基础的，如文章开头所述有2个问题，不能调度太多的任务，而且精度也不准。根据java api文档，其内部实现是一个二叉堆，调度一个任务的时间复杂度是O(logn)</p>
<h3 id="java-ScheduledThreadPoolExecutor"><a href="#java-ScheduledThreadPoolExecutor" class="headerlink" title="java ScheduledThreadPoolExecutor"></a>java ScheduledThreadPoolExecutor</h3><p>这是java 5 开始引入的一个定时调度器，用来代替之前的Timer和TimerTask组合，这个调度器可以指定多个线程来执行调度任务。另外执行调度任务时，还可以catch住任务抛出的异常，还 不会影响其他任务的调度。另外还可以重载他的afterexecute方法来对异常做处理。</p>
<h3 id="Netty时间轮io-netty-util-HashedWheelTimer"><a href="#Netty时间轮io-netty-util-HashedWheelTimer" class="headerlink" title="Netty时间轮io.netty.util.HashedWheelTimer"></a>Netty时间轮io.netty.util.HashedWheelTimer</h3><p>这是上边所述的方案6的典型实现，hash 时间轮加无序桶。 默认的时间轮盘值是512，tick time是100ms。如上所述，因为现实使用中，时间跨度度不会很大，方案6是适用于现实中绝大多数定时任务调度场景。</p>
<h3 id="Kafka内置的时间轮"><a href="#Kafka内置的时间轮" class="headerlink" title="Kafka内置的时间轮"></a>Kafka内置的时间轮</h3><p>这是上边所述的方案7的典型实现，多级时间轮。kafka使用这个时间轮来实现消息的延迟生产、拉取等longpoll操作。</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>时间轮算法分析和应用</p><p><span>文章作者：</span>王军飞 jonefeewang@gmail.com</p><p><span>发布时间：</span>2023-04-10</p><p><span>最后更新：</span>2024-03-24</p><p><span>原始链接：</span><a href="/2023/04/10/时间轮算法分析和应用/">https://wangjunfei.com/2023/04/10/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E7%94%A8/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://wangjunfei.com/2023/04/10/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E7%94%A8/"></i></span></p><p><span>版权声明：</span>原创文章转载请注明出处</p></div><br><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="https://wangjunfei.com/2023/04/10/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E7%94%A8/" data-id="cm7b7f8t6001u2f821h8bb7qz" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASYAAAEmCAAAAADqr2IGAAAEi0lEQVR42u3by47iQAwFUP7/pxlpdqNpgq9dtDCcrFoBksrJovzq26183P8ej/7+/7j+ZuX613epnL++2u0VByZMmDBhekum++Vxfenrh7++yyOm+quq8PWu88NvMWHChAnTcqZeEFBHrF/hGrHy6eRqD89jwoQJE6YvYOotoh4KnNrUJ4iYMGHChOmbmeqPl15tXnSel6ExYcKECdNnM/XKppMNeBJwpIXpekP0QC0cEyZMmDC9GdN8cGfv378634QJEyZMmH6d6X70mJd660Oo9RGiA8+FCRMmTJjWMqVjppNxnN5mnI4EXcP1WpuYMGHChGkv07xEOw8F0o0/pZykvv/ETZgwYcKEaSHTNcd8RDXd1CdJb7p3x41MTJgwYcK0kCkd2TlV2E2DgzSbn7/gh6EAJkyYMGFayNS7cXyzwQOcGtCpfPrDdzBhwoQJ03KmXvI5+bReJp5MjdZbsE8oMWHChAnTWqZ6g7BeAp48TLqGdD1pMh/3UTFhwoQJ0xsz1Uu3p0ZO06tVUuJ0JCgOSjBhwoQJ01qmeoo4aVv2tuHesGz9t3HqiwkTJkyYVjH1blM502thvoKvzvQwLMCECRMmTGuZKrdMl9jb/usjsL32Z++3mDBhwoRpL1Oamp4aiOm9mF5I0RtLfRIxYcKECROmJUz1tDNtBKaJcVq0nQQxaSCCCRMmTJj2MlXakGkpdp6gHsvmy1hPXjYmTJgwYVrLNL9Nup3PH69eCO6NBx1eLiZMmDBhegOmNCyYLLpXLO4lz5PC9JOKOCZMmDBhWshU2fivgXpl2cqD9eKa3ohqqRaOCRMmTJgWMtU3zt7wzWQ4dd6znYz1YMKECROmvUzpeGi9+ddDTx9vPrJTCkowYcKECdNypnkxt/f9ydDPPTzSlLjZR8WECRMmTG/GlBZeTy0u2IzLv50k4aXfYsKECROmhUyVJl+66Pl30hAkLebGLw8TJkyYMK1lSsu4o9Sx1QTt0ael52bJGxMmTJgwrWJKU9lTQcD1mUnbsnfloNSLCRMmTJiWMDUnW1sb/6RkXCkiT8Z0SqVeTJgwYcK0iqm3fdY31HTcJw0g0vPpK8eECRMmTJ/ElI7IpMM3aYgwSXSb2f/1ZBMmTJgwYVrIVGn79dLRs8HBZEhoMhSLCRMmTJg+g6myodYvnTY101AgHb453DrFhAkTJkyrmOo0vU97jzfJOutDPPV0GhMmTJgwbWeqP3CvdDtpYZ4tBzeL1JgwYcKE6SOYeqlpfWi1jlj55uQFxI1bTJgwYcK0lmm+GU9GRVPi5iOFR+k6mDBhwoRpCVNvKKeS7qZl2VFq2hrKCQrTmDBhwoRpLdNkm0yDgApcytFb/wvvhQkTJkyY3pKpNzDaS0QrIUKvcNwr4NZfKiZMmDBh2s7USyDrafDZgmzKOmm7YsKECROmb2OaLDEtCqdrmAywPjmPCRMmTJi+gKm39HQcp1cOTidt4nYpJkyYMGFazpT+60VaGu6VcVPoNM0OVoUJEyZMmNYynWocVkZagw24l6AebXZiwoQJE6blTH8AajRXSANAH8cAAAAASUVORK5CYII=">分享</a><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kafka-netty-%E6%97%B6%E9%97%B4%E8%BD%AE/" rel="tag">kafka netty 时间轮</a></li></ul></div><div class="post-nav"><a class="pre" href="/2023/06/15/Apache-pulsar%E5%AF%B9zookeeper%E7%9A%84%E4%BE%9D%E8%B5%96%E5%92%8C%E5%8E%BB%E9%99%A4%E5%88%86%E6%9E%90-%E4%B8%80/">Apache pulsar对zookeeper的依赖和去除分析(一)</a><a class="next" href="/2021/12/01/Kafka%E5%8E%BBZookeeper%E6%8F%AD%E7%A7%98/">Kafka去Zookeeper揭秘</a></div><div class="nofancybox" id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == 'true' ? true : false;
var verify = 'true' == 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'FNjCNRwQqC3sTPP04DfRFIk9-gzGzoHsz',
  appKey:'LzCq5t6a6RTkwXQVr8xLk0yj',
  serverURLs:'',
  placeholder:'请理性评论',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10'
})
</script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://wangjunfei.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>Always be the best</p><a class="info-icon" href="mailto:jonefeewang@outlook.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/jonefeewang" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/">分布式技术</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A1%E8%99%9A-%E4%BA%A4%E6%B5%81%E6%B2%9F%E9%80%9A/">务虚-交流沟通</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A1%E8%99%9A-%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E8%AE%BA/">务虚-管理方法论</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E4%BC%98%E5%8C%96/">磁盘读写优化</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Message-Queue/" style="font-size: 15px;">Message Queue</a> <a href="/tags/Rust/" style="font-size: 15px;">Rust</a> <a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/Pulsar/" style="font-size: 15px;">Pulsar</a> <a href="/tags/StoneMQ/" style="font-size: 15px;">StoneMQ</a> <a href="/tags/Apache-Pulsar/" style="font-size: 15px;">Apache Pulsar</a> <a href="/tags/Apache-Bookkeeper/" style="font-size: 15px;">Apache Bookkeeper</a> <a href="/tags/Apache-Kafka/" style="font-size: 15px;">Apache Kafka</a> <a href="/tags/Apache-pulsar-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-kafka-RocketMQ/" style="font-size: 15px;">Apache pulsar 消息队列 kafka RocketMQ</a> <a href="/tags/kafka-raft-kraft-zookeeper/" style="font-size: 15px;">kafka raft kraft zookeeper</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 15px;">消息队列</a> <a href="/tags/rocketmq/" style="font-size: 15px;">rocketmq</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/pulsar/" style="font-size: 15px;">pulsar</a> <a href="/tags/%E5%8A%A1%E8%99%9A-%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E8%AE%BA/" style="font-size: 15px;">务虚-管理方法论</a> <a href="/tags/%E5%8D%8E%E4%B8%BA/" style="font-size: 15px;">华为</a> <a href="/tags/%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E8%AE%BA/" style="font-size: 15px;">管理方法论</a> <a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 15px;">管理</a> <a href="/tags/%E5%8A%A1%E8%99%9A-%E9%A2%86%E5%AF%BC%E6%A2%AF%E9%98%9F/" style="font-size: 15px;">务虚-领导梯队</a> <a href="/tags/%E5%8A%A1%E8%99%9A/" style="font-size: 15px;">务虚</a> <a href="/tags/%E5%8D%8F%E4%BD%9C/" style="font-size: 15px;">协作</a> <a href="/tags/%E8%BD%AF%E7%B4%A0%E8%B4%A8/" style="font-size: 15px;">软素质</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/" style="font-size: 15px;">分布式技术</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/consensus-algorithm/" style="font-size: 15px;">consensus algorithm</a> <a href="/tags/zab/" style="font-size: 15px;">zab</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE/" style="font-size: 15px;">分布式协议</a> <a href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/" style="font-size: 15px;">一致性算法</a> <a href="/tags/%E6%96%B9%E6%B3%95%E8%AE%BA-%E8%BD%AF%E7%B4%A0%E8%B4%A8%E6%8F%90%E5%8D%87/" style="font-size: 15px;">方法论 软素质提升</a> <a href="/tags/kafka-netty-%E6%97%B6%E9%97%B4%E8%BD%AE/" style="font-size: 15px;">kafka netty 时间轮</a> <a href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" style="font-size: 15px;">云原生</a> <a href="/tags/%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97/" style="font-size: 15px;">流式计算</a> <a href="/tags/%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E4%BC%98%E5%8C%96/" style="font-size: 15px;">磁盘读写优化</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/02/10/Announcing-Stonemq-A-high-performance-and-efficient-message-queue-developed-in-Rust/">Announcing Stonemq: A high-performance and efficient message queue developed in Rust</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/12/25/Apache-Pulsar%E7%9A%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/">Apache Pulsar的存储模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/09/15/Apache-pulsar%E5%AF%B9zookeeper%E7%9A%84%E4%BE%9D%E8%B5%96%E5%92%8C%E5%8E%BB%E9%99%A4%E5%88%86%E6%9E%90-%E4%BA%8C/">Apache pulsar对zookeeper的依赖和去除分析(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/06/15/Apache-pulsar%E5%AF%B9zookeeper%E7%9A%84%E4%BE%9D%E8%B5%96%E5%92%8C%E5%8E%BB%E9%99%A4%E5%88%86%E6%9E%90-%E4%B8%80/">Apache pulsar对zookeeper的依赖和去除分析(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/10/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E7%94%A8/">时间轮算法分析和应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/01/Kafka%E5%8E%BBZookeeper%E6%8F%AD%E7%A7%98/">Kafka去Zookeeper揭秘</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/09/15/PRFAQ%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/">「转」PRFAQ编写规范</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/09/13/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95%E8%AE%BA%E6%B1%87%E9%9B%86/">「转」几种常见的工作方法论汇集</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/14/%E8%BD%AF%E7%B4%A0%E8%B4%A8%E8%9E%BA%E6%97%8B%E4%B8%8A%E5%8D%87/">软素质螺旋上升</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/22/Mafka%E5%85%A8%E9%93%BE%E8%B7%AF%E5%BC%B9%E6%80%A7%E4%BC%B8%E7%BC%A9%E6%BC%94%E8%BF%9B%E7%AD%96%E7%95%A5/">Mafka全链路弹性伸缩演进策略</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">王军飞的随笔.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>