<!DOCTYPE html><html lang="en-US"><head><meta name="google-site-verification" content="IqPxX6jMzoqSIvuvpvuP9PCF7niBjR9EBY0UfP9MHEU"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Rex Wangs blog"><title>Apache Pulsar的存储模型 | Rex Wang</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Apache Pulsar的存储模型</h1><a id="logo" href="/.">Rex Wang</a><p class="description">always be the best</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Apache Pulsar的存储模型</h1><div class="post-meta">2023-12-25<span> | </span><span class="category"><a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 4.5k</span><span class="post-meta-item-text"> Words</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 16</span><span class="post-meta-item-text"> Minutes</span></span></span></div><a class="disqus-comment-count" href="/2023/12/25/Apache-Pulsar%E7%9A%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/#vcomment"><span class="valine-comment-count" data-xid="/2023/12/25/Apache-Pulsar%E7%9A%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/"></span><span> Comment</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Inhalte</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bookkeeper%E5%AD%98%E5%82%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">Bookkeeper存储的设计和实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#entry%E7%9A%84%E5%86%99%E5%85%A5%E9%80%BB%E8%BE%91"><span class="toc-number">3.1.</span> <span class="toc-text">entry的写入逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WriteCache%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.1.</span> <span class="toc-text">WriteCache的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#entry-log%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.2.</span> <span class="toc-text">entry log文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#journla%E7%9A%84%E5%86%99%E5%85%A5"><span class="toc-number">3.1.3.</span> <span class="toc-text">journla的写入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#entry%E7%9A%84%E8%AF%BB%E5%8F%96"><span class="toc-number">3.2.</span> <span class="toc-text">entry的读取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#readCache%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.1.</span> <span class="toc-text">readCache的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ledger%E7%9A%84%E6%B8%85%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">ledger的清理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%9D%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">思考</span></a></li></ol></div></div><div class="post-content"><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Pulsar实际上是三个组件的组合体Apache Pulsar+Apache Bookkeeper+RocksDB。 Bookkeeper是负责消息的存储，Pulsar负责队列和消费的概念模型塑造，RocksDB是Bookkeeper内部用来存储kv索引用的，相关的概念介绍，可以参考下我之前的博客:<a href="/2021/03/26/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%9A%E7%95%8C%E8%B0%83%E7%A0%94/" title="消息队列业界调研">&lt;&lt;消息队列业界调研&gt;&gt;</a>。本篇来详细分析一下Pulsar的消息存储模型。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>其实说到底，Pulsar的消息存储最底层就是ledger，这个概念也是Bookkeeper中的概念，ledger由很多小段的segement组成，这些segment在bookkeeper中称之为entry log，所以要彻底说清楚Pulsar的存储，还得由Bookkeeper来说起。entry log是什么？是不同的entry写到一个文件里，这里的entry可以理解为消息，一个entry从属于某一个ledger。所以，反过来说，一个ledger由entry组成，不同的ledger在存储时都写入了一个称为entry log的文件里。</p>
<p>Bookkeeper本身是一个有限的流式数据存储，这里说的有限是对应与Kafka的无限流式数据存储。kafka中一个log流是有开始没有结束，一个log代表一个topic的一个partition，只要队列有消息，这个流就不会终结，永远存储在这个log文件里(具体文件会滚动，但存储的都是这个partition的消息)。而bookkeeper则不同，它是一个有限的流式存储，一个ledger代表队列的一个partion数据，他有开始也有结束，开始就是有消息生产就有了开始，结束时是当消息的生产者掉线了，死机了，或是生产这主动关闭了，这时就是这个ledger的终点，这时候ledger会被关闭掉，如果下一个生产者继续往这个partition里生产，则需要创建一个新的ledger。在整个ledger的生命周期内，它只有三种状态，open/in_recovery/(fenced)closed，</p>
<ul>
<li>open：在正常接收生产的消息数据</li>
<li>in_recovery: 读取客户端在试图恢复之前未被复制到所有WQ的消息，这时停止接受新的消息数据。</li>
<li>(fenced)/closed: 恢复完数据后，客户端关闭这个ledger，不再接受任何新的消息数据。</li>
</ul>
<p>bookkeeper对生产端有两个严格的要求:</p>
<ol>
<li>第一个是任何时间段必须只能由一个客户端在生产，这也就是为什么pulsar里bundle只能被一个broker负责，不能由不同的 broker同时负责，那样就会有两个生产端同时生产了，会产生脑裂，违反了bookkeeper的要求。</li>
<li>第二个是生产时必须提供一个顺序的entryId，也就是消息Id，这个限制是方便对ledger内的fragment的进行按顺序的消息管理，比如0-100的fragemnt的ensemble是(B1,B2,B3)，100-500的ensemble是(B2,B3,B4)，如果entryId不是顺序产生的，这个fragment是无法归类的，到底哪一段，哪一个范围的entry是哪些ensemble负责的。确定ensemble的信息非常重要，因为消息在读取的时候，需要这个信息，比如要读取entryId是233的消息，有了这个fragment信息，我就知道从哪个bookkeeper机器上读取了。</li>
</ol>
<p>再说回到pulsar，因为bookkeeper只提供了ledger这个概念，根本没有消息队列里的topic/group/cursor这些概念，直接拿到pulsar里使用是无法使用的，所以pulsar在ledger的基础之上封装了一次，将topic的partiton封装为一个ledger，在pulsar内部叫做managedLedger，一个partition包含多个ledger，因为上边讲到ledger是一个有限数据流，因为broker死机，或者entry log的size达到上限，都需要结束这个ledger，重新create一个。所以，在puslar里，一个多partiton的topic，每个partition其实是多个ledger组成的，这些信息存储在zk的目录上，具体参考我之前的博客<a href="/2023/06/15/Apache-pulsar%E5%AF%B9zookeeper%E7%9A%84%E4%BE%9D%E8%B5%96%E5%92%8C%E5%8E%BB%E9%99%A4%E5%88%86%E6%9E%90-%E4%B8%80/" title="Apache pulsar对zookeeper的依赖和去除分析(一)">&lt;&lt;Apache pulsar对zookeeper的依赖和去除分析(一)&gt;&gt;</a>。</p>
<p>所以，pulsar自身并没有存储消息数据，所有的消息数据，都被存放到了bookkeeper上，所有抽象出来的topic/group/cursor元信息内容都被存储到了zk上，它自己本身是无状态的。</p>
<h1 id="Bookkeeper存储的设计和实现"><a href="#Bookkeeper存储的设计和实现" class="headerlink" title="Bookkeeper存储的设计和实现"></a>Bookkeeper存储的设计和实现</h1><p>bookkeeper生成的物理文件有三种，一个是journal，一个就是entry log，一个是logmark文件</p>
<ul>
<li>journal：类似zookeeper中的transaction log，或者是write log，短期存储，，会按照大小分割和滚动,所有ledger发送的消息都会在这里实际落盘后，才会ack客户端成功。</li>
<li>entry log: 实际存储entry的文件，是一个长期存储，所有的ledger都会写到一个entry文件内部，相同ledger的entry会做排序，方便读取的时候顺序读取相同ledger的entry。(实际内部还有另外一个实现option，每个ledger一个entry log，不过因为ledger很多，这样会产生很多碎文件)</li>
<li>logmark文件：标注journal文件内一个位置点，比如是哪个journal文件内的哪个offset点。</li>
</ul>
<p>每个ledger还有一个masterKey，它是一个ledger的访问口令，在ledger生成时会指定一个，以后ledger的访问都会在请求中校验这个key。</p>
<h2 id="entry的写入逻辑"><a href="#entry的写入逻辑" class="headerlink" title="entry的写入逻辑"></a>entry的写入逻辑</h2><p>Bookkeeper使用Netty，netty worker thead解析到是addEntry(添加一条消息)请求后，交由write thread pool来处理具体的entry插入。write thread pool是一个ordered Excutor线程池，所谓ordered Executor，意思所有属于同一个ledger的entry 插入都会交由同一个固定的线程去负责执行，以减少乱序和并发。每个ordered thread的任务池大小，以及write thread pool大小都可以在配置文件中设置。由此可见bookkeeper在插入entry时，并没有批量插入的接口，orderedExcutor的固定线程在执行queue中的任务时，虽然是批量获取，执行时仍然是一个一个的执行插入，并没有类似kafka中的批量消息插入。</p>
<p>ordered executor在执行具体某个ledger的entry插入任务时，分两步进行，第一步是插入EntryLog，第二步是插入Jornal，在jornal插入并刷盘后，再回调entry的插入成功逻辑，ack客户端插入成功。</p>
<p>插入entryLog时，实际上第一步先插入到WriteCache内，这是一个分段cache，有两个，一个是当前正在被使用的(active)，另一个是当前正在被flush到磁盘上(in_flush)。active的就是平常entry先插入到这里，in_flush的是正在flush WriteCache内的entry到磁盘上，flush完成后这个cache会被清空，等待active的cache插满之后，和它做个交换，以保障正常的插入流程能继续进行，当然如果flush的慢的话，也会形成反压，导致WriteCache的插入被block，进而导致插入请求超时。同时， active 的WriteCache插满之后，会做checkpoint，所谓的checkpoint就是一个时间点，这个时间点会在Journal内做个标记，标记一下Journal最后一次flush 磁盘时插入的entry所在的journal文件id和position，称为LogMark,就是上边讲的log mark文件存储的内容，在WriteCache内的数据被flush到磁盘后，entry log会通知jounal，当前时间点之前的entry已经完全flush到磁盘上了，不需要journal内的数据了，可以将刚才做的checkpoint之前的记录删除掉，腾出磁盘空间。</p>
<p>由此可见，entry的插入，在Jornal之内是同步插入的，而entrylog则是异步插入的, Jornal保障数据持久化之后，会ack客户端插入成功。entrylog虽然是异步插入，但是可以通过write cache类形成对客户端的反压，block 所有entry的插入请求。Journal有了checkpoint之后，在单台bookkeeper宕机时，因为entry log是异步flush磁盘的，有可能部分entry还未flush而丢失，这时，就可以根据checkpoint从journal内做一次replay，把丢失的entry给找回来。</p>
<p>entry在插入entry log时，会保留位置信息，也就是所在entry log文件的id，和position，位置信息的key是ledger id+ entry id, value是 entry log文件的id和文件内position组合起来的一个lang值，将这个key value pair保存到rocks db内(或index文件内，见下文)。</p>
<h3 id="WriteCache的实现原理"><a href="#WriteCache的实现原理" class="headerlink" title="WriteCache的实现原理"></a>WriteCache的实现原理</h3><p>bookkeeper的配置文件内，会设置最大Write Cache大小，每段Cache的段大小，因为在内部，整个缓存区域是被分成段来缓存的，bookkeeper默认设置每段缓存的大小是1G，所以如果总缓存大小是2G的话，每段大小是1个G。<br>使用分段来缓存具有很多优势:</p>
<ol>
<li>提高读写速度，因为每段的缓存更小，可以更快的定位entry所在的位置，进行快速读取</li>
<li>方便并发控制，这个原理跟java语言中的ConcurrentHashMap类似，不再赘述</li>
<li>还可以减少内存碎片，因为每个小段可以作为整体来分配和回收，整体利用，减少了碎片的形成。</li>
</ol>
<p>在写入Cache时，会先计算一个全局offset，设置size大小为align64，就是接近64的最小倍数，防止在CPU L1 Cache产生线程竞争。为什么是64？因为java中Long型的长度是64位，使用Long型来计算Bits码，防止Cache最小段大小超过Long型所能表示的最大值。然后使用Bits码和掩码，快速定位到应该放到哪一段，和段内的offset(这个算法是存储系统经常使用的方法)。</p>
<p>Cache 内部保存了一个HashMap，是一个(ledgerId,entryId)到(offset,size)的映射，注意这里的offset是全局offset，size是这个entry的大小字节数量。</p>
<p>读取cache内的某个entry的时候，使用全局offset反算出entry所在的段和位置。</p>
<h3 id="entry-log文件"><a href="#entry-log文件" class="headerlink" title="entry log文件"></a>entry log文件</h3><p>默认的entry logger 是使用java的文件I/O来写entry log文件，bookkeeper额外提供了使用JNI来写文件的DirectEntryLogger实现，来加快文件写的速度。使用java文件I/O实现的entry logger还有两种方式，一种是将entry log全部写进一个文件中，另外一种是每个ledger一个entry log，前者是默认的。</p>
<p>entry log文件存储的管理，由bookkeeper内部抽象出来的LedgerStorage来管理，这个接口有3种实现:</p>
<ol>
<li><p>InterleavedLedgerStorage 没有使用内存缓存最近插入的entry，entry在写入和读取直接进行文件操作。索引存储使用了多页的jvm直接内存来缓存，缓存的数据是ledger id+ entry id -&gt; entry log id 和 entry log内 position组合成的long型数据</p>
</li>
<li><p>SortedLedgerStorage  是InterleavedLedgerStorage的扩展，在它的基础上加了一层最近插入的entry内存缓存，缓存内部使用跳表map来实现，一共两个，一个作为当前在插入的缓存，另外一个作为后台flush entry到文件时使用，flush完成后，缓存清空，等待active的写满之后与它做交换。</p>
</li>
<li><p>DbLedgerStrage 使用WriteCache和ReadCache来缓存最近写入的entry和最近读取的entry，索引存储使用rocksDB来做kv存储，所以取名DBLedgerStorage，也是上面两节讲到的entry插入流程中使用到的。每次WriteCache写满之后，触发Journal checkpoint，然后触发ledgerStorage checkpoint， ledgerStoarge checkpoint时会flush数据到磁盘，然后通知checkpoint source自身已完成，这时checkpoint source是Jornal，journal收到通知后，删除旧的journal日志。(DbLedger Storage的set checkpointer()方法是空的，虽然传进来的SyncThread但是没设置，所以在dbledgerStorage内，syncThread并未起到作用。)</p>
</li>
</ol>
<h3 id="journla的写入"><a href="#journla的写入" class="headerlink" title="journla的写入"></a>journla的写入</h3><p>entry交给journal后会暂存在journal的缓冲队列中，交由 journal的专用thread来驱动写入文件，到达一定条件后flush文件到到磁盘上，最后再ack entry的插入操作算成功。jornal触发批量刷盘的条件:</p>
<ol>
<li>group commit等待的时间超过了设定的时间 </li>
<li>缓存的entry数量超过了设定的值</li>
<li>缓存queue内元素暂时为空<br>当这些条件中的某一个达到时，一般会生成一个forcewrite request，放到force write thread的任务队列里，这个thread会一直运行，只要队列内有请求就会执行flush操作。执行的第一步先flush journal文件到此盘，然后挨个回调被flush 的entry的回调函数，在回调函数内，ack给客户端entry插入成功。</li>
</ol>
<p>syncthread<br>这是一条独立运行的thread，他会定期运行，先对ledger storage进行checkpoint，其实就是flush active write cache内的entry到磁盘，，然后通知jornal的,让journal删除checkpoint之前的文件，清理空间。</p>
<h2 id="entry的读取"><a href="#entry的读取" class="headerlink" title="entry的读取"></a>entry的读取</h2><p>Netty worker thread在解析到是read entry操作时，会交由专门的read thread pool处理读取请求。如果是long poll read会交由专门的long poll thread pool来处理，如果请求的header内包含priority &gt;0，则表示是一条high priority read请求，会交由专门的high priority pool来完成，以保证高优先级任务能顺利完成。<br>entry读取的请求实际上包含了多种请求:</p>
<figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ReadRequest{</span><br><span class="line">    enum Flag{</span><br><span class="line">        FENCE_LEDGER<span class="operator">=</span><span class="number">1</span><span class="comment">;</span></span><br><span class="line">        ENTRY_PIGGYBACK<span class="operator">=</span><span class="number">2</span><span class="comment">;</span></span><br><span class="line">    }</span><br><span class="line">    Optional Flag flag<span class="operator">=</span><span class="number">100</span><span class="comment">;</span></span><br><span class="line">    required int64 ledgerId<span class="operator">=</span><span class="number">1</span><span class="comment">;</span></span><br><span class="line">    required int64 entryId<span class="operator">=</span><span class="number">2</span><span class="comment">;</span></span><br><span class="line">    optional bytes masterKey<span class="operator">=</span><span class="number">3</span><span class="comment">;</span></span><br><span class="line">    optional int64 previousLAC<span class="operator">=</span><span class="number">4</span><span class="comment">;</span></span><br><span class="line">    optional int64 timeOut<span class="operator">=</span><span class="number">5</span><span class="comment">;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>1.可以fence一个ledger<br>2.也可以正常读取一个entry<br>3.如果带有previousLAC，则是一个longpoll操作，超时时间是请求里带的超时时间，请求的超时计算使用的是netty自带的hash时间轮</p>
<p>在读取entry时，ledger storage先从write cache内查找要读取的entry，然后再查找read cache内，最后没有的话会去读取磁盘，将读取到entry添加到read cache 内，并额外顺序读取额外的一批entry到read cache内，此处并未交由异步线程去读取，可能会影响真正需要的entry的读取速度。</p>
<h3 id="readCache的实现"><a href="#readCache的实现" class="headerlink" title="readCache的实现"></a>readCache的实现</h3><p>read cache的默认大小是jvm可用堆外内存的1/4，额外预读entry大小不会超过read cache的一半，这也是防止一次预读不会占用太多空间。read cache内部也是将可用内存划分为几段来使用，具体优势跟write cache一样，它是一个环形存储，默认使用新的覆盖旧的缓存，这也是因为消息队列的特点，消息顺序消费，默认先淘汰旧的entry。</p>
<h2 id="ledger的清理"><a href="#ledger的清理" class="headerlink" title="ledger的清理"></a>ledger的清理</h2><p>bookkeeper本身是不带entry清理功能的，你只能主动删除ledger，删除ledger接口内部只会删除保存在zk上ledger的metadata数据，bookkeeper内部有一个GarbageCollector，会定期删除entry log内被删除ledger的实际数据。相对于pulsar来说，pulsar本身增加了队列的保存期限语义，队列被删除、或者保存超期，pulsar会主动调用bookeeper删除ledger。</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol>
<li><p>Pulsar声称自己是原生的存算分离架构，不同于kafka的存储+计算，其实这么一看，也是不得已而为之，因为bookkeeper和pulsar两个组件并不是一起发明的，pulsar只是借用了bookkeeper做存储，自己抽象出了一些消息队列的概念，拼装起来成为一个消息队列，其实质存储实际是靠bookkeeper来完成的。</p>
</li>
<li><p>bookkeeper借鉴了LSM tree架构，journal相当于write ahead log， write/read cache类似与借鉴了MemTable，而entry log类似与SSTable，这种结构天然是为了高效写入数据而生。journal和entry log文件的写入，都是大块数据的写入，多个队列掺杂在一起，文件不会因为队列增多，队列partition增多而放大，出现像kafka一样的大量碎片文件，从而降低了集群的写入量。虽然bookkeeper建议双盘配置，journal使用ssd磁盘，entry log使用另外一块磁盘，实际entry log的写入也会反压单机的写入速度，即便journal这时有冗余的iops，也是无可奈何，没办法接收更多的写入请求。</p>
</li>
<li><p>journal文件写入使用了group commit来硬刷磁盘， entry log文件的写入轻度使用了page cache，在flush时仍然会被异步刷到磁盘上。不像kafka一样，完全使用page cache，其实这也是kafka无奈之举，天量的topic和partition产生的replica文件的写入，如果都去靠磁盘flush来保障持久性，磁盘IO性能势必会直线下降，只能避免主动flush，交由操作系统的page cache 自动来管理，但page cache的不可控性，大量小碎文件带来的磁盘碎片，多至数万个replica的复制，即便是SSD磁盘组成的集群，性能也会直线下降。</p>
</li>
<li><p>一致性方面，bookkeeper自身只是一个无脑存储单元，ledger的副本，都是靠bookkeeper的客户端来完成，由客户端按照bookkeeper集群当前的数量，以及客户端的配置，临时生成ensemble，来完成多副本的保障，所以一致性，持久性都是靠客户端来完成，中间主要靠pulsar这个客户端来管理。而Kafka是靠自身的多副本主动复制机制来完成的，服务端自己来完成。相对来说，kafka的一致性和持久性会更统一一些，逻辑都在一块，而pulsar比较分散，需要客户端来主导，bookkeeper服务端来配合完成。</p>
</li>
<li><p>上边说到bookkeeper是一个有限数据流，当单机宕机后，客户端会主动再已启动一个预设定数量的ensemble，继续完成消息数据的而写入，而且副本数量没有少，比如EM设定3，WQ设定3，AQ设定2，副本数量是3个，当一台机器宕机后，如果集群有冗余，客户端可以快速形成一个新的同等ensemble，因为它的数据流是分段形成的，新的段(ledger)不必一直设定在原有的机器上，可以很快在替代机器上生成。<br>而kafka不行，因为是无限数据流，集群宕机一台后，副本数量少一个，不能很快形成一个新的替代replica，必须替换机器，重新reassign partition leader和follower，来搬运历史数据，相对来说速度比较慢，会有一个较长的副本缺少的空窗期。</p>
</li>
</ol>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>Title: </span>Apache Pulsar的存储模型</p><p><span>Author: </span>Rex Wang rexwang735@gmail.com</p><p><span>Date: </span>2023-12-25</p><p><span>Last Update: </span>2024-03-24</p><p><span>Blog Link: </span><a href="/2023/12/25/Apache-Pulsar的存储模型/">https://wangjunfei.com/2023/12/25/Apache-Pulsar%E7%9A%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://wangjunfei.com/2023/12/25/Apache-Pulsar%E7%9A%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/"></i></span></p><p><span>Copyright Declaration: </span>Plz credit the original source when reposting</p></div><br><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="https://wangjunfei.com/2023/12/25/Apache-Pulsar%E7%9A%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/" data-id="cmc1cedql0002dl822dqw5la9" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAADKklEQVR42u3aW27jQAwEwNz/0t4DZGU3yQkg0aWvBfzQlAKYSzZ/fuLr9eu6ejX/tuo3z+9bvrCxsbEfwn69vZL3XL0zAbyHnT0nNjY29m52UmaSV3vl5AqQP7jcgo2NjY2dl5n3RaUKnpwNGxsbGztpNpJHUG1XkkYFGxsbGzsf1lRLVLXwVEdLyfccmKVhY2Nj357di2bv+e8/ybexsbGxb8x+Fa/qA8qHUHlrNL+wsbGxN7HzAnBqDDQvQkmcEJ0fGxsbewW799N/akEzL1enAmlsbGzsrexkwXHShCQlLX9PHjx/6MCwsbGxV7CTFZxqAcvbmFMBcP4qNjY29jewe+syyQgpWoiM14N6TQg2Njb2PnZvTJO3CtXYYNKK5I8SGxsbeze7F/pWA+BTKzvJn6oQD2BjY2M/ln127D5Z5czP04scsLGxsfexq5jCf/eDwtMc6w+WdbCxsbG/gT0pUXkEO//U5M+AjY2NvYl96smdjWbPRgj/uQs2Njb2OnZ1dTIvYL1WJG9OkpDgckcJGxsbexE7OXp1abIXwebNRnVEdVm3sbGxsR/OzhuJXtw7X51MClJ1OIWNjY29id27fb6akw+P8mYmH0Jd3gUbGxt7KbtabPJm41QrUo2NP+ycYmNjY69gV/d68sPlZS+/Yy8ejtZ3sLGxsVew8zCgGs32lnXyh9gLM7CxsbF3sE8N7vOHkiDzdZy8FbnMt7GxsbFXsKurkL2Itzr66UXOURHFxsbGXsqeNwn56kxetCYBQ7O7wsbGxn4Uu7p82TtudWVnMvTPP4uNjY29j90LX3sPZdKu5GXsQ/HDxsbGXsfOf9vzIHbSqJxqWi4/hY2Njb2OPV+X6bUoeUMy3z/CxsbG3sfutRPVQlINkvNooVpum70UNjY29o3Z1Z/+5Ij5cavfnJS35AzY2NjY+9i9xmBSkM5Gtr1FImxsbOx97OrKY68ZqI6rqvFA/iixsbGxsSejpXnAkDchhXwbGxsb+yvZf7Gak5el3qooNjY29lZ2Hu72qJMlnt6Q61g8gI2NjX17dnlbszXor46W5mOmXoHExsbGfhT7H8zYF3LXdx90AAAAAElFTkSuQmCC">Aktie</a><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Apache-Bookkeeper/" rel="tag">Apache Bookkeeper</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Apache-Kafka/" rel="tag">Apache Kafka</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Apache-Pulsar/" rel="tag">Apache Pulsar</a></li></ul></div><div class="post-nav"><a class="pre" href="/2025/02/10/Announcing-Stonemq-A-high-performance-and-efficient-message-queue-developed-in-Rust/">Announcing Stonemq: A high-performance and efficient message queue developed in Rust</a><a class="next" href="/2023/09/15/Apache-pulsar%E5%AF%B9zookeeper%E7%9A%84%E4%BE%9D%E8%B5%96%E5%92%8C%E5%8E%BB%E9%99%A4%E5%88%86%E6%9E%90-%E4%BA%8C/">Apache pulsar对zookeeper的依赖和去除分析(二)</a></div><div class="nofancybox" id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == 'true' ? true : false;
var verify = 'true' == 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'FNjCNRwQqC3sTPP04DfRFIk9-gzGzoHsz',
  appKey:'LzCq5t6a6RTkwXQVr8xLk0yj',
  serverURLs:'',
  placeholder:'Please provide constructive and respectful feedback.',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10'
})
</script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://wangjunfei.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="Über"><img class="nofancybox" src="/img/avatar.png"/></a><p>Always be the best</p><a class="info-icon" href="mailto:rexwang735@gmail.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/jonefeewang" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/">分布式技术</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A1%E8%99%9A-%E4%BA%A4%E6%B5%81%E6%B2%9F%E9%80%9A/">务虚-交流沟通</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A1%E8%99%9A-%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E8%AE%BA/">务虚-管理方法论</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E4%BC%98%E5%8C%96/">磁盘读写优化</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Apache-Pulsar/" style="font-size: 15px;">Apache Pulsar</a> <a href="/tags/Apache-Bookkeeper/" style="font-size: 15px;">Apache Bookkeeper</a> <a href="/tags/Apache-Kafka/" style="font-size: 15px;">Apache Kafka</a> <a href="/tags/Apache-pulsar-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-kafka-RocketMQ/" style="font-size: 15px;">Apache pulsar 消息队列 kafka RocketMQ</a> <a href="/tags/Message-Queue/" style="font-size: 15px;">Message Queue</a> <a href="/tags/Rust/" style="font-size: 15px;">Rust</a> <a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/Pulsar/" style="font-size: 15px;">Pulsar</a> <a href="/tags/StoneMQ/" style="font-size: 15px;">StoneMQ</a> <a href="/tags/kafka-raft-kraft-zookeeper/" style="font-size: 15px;">kafka raft kraft zookeeper</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 15px;">消息队列</a> <a href="/tags/rocketmq/" style="font-size: 15px;">rocketmq</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/pulsar/" style="font-size: 15px;">pulsar</a> <a href="/tags/%E5%8A%A1%E8%99%9A-%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E8%AE%BA/" style="font-size: 15px;">务虚-管理方法论</a> <a href="/tags/%E5%8D%8E%E4%B8%BA/" style="font-size: 15px;">华为</a> <a href="/tags/%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E8%AE%BA/" style="font-size: 15px;">管理方法论</a> <a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 15px;">管理</a> <a href="/tags/%E5%8A%A1%E8%99%9A-%E9%A2%86%E5%AF%BC%E6%A2%AF%E9%98%9F/" style="font-size: 15px;">务虚-领导梯队</a> <a href="/tags/%E5%8A%A1%E8%99%9A/" style="font-size: 15px;">务虚</a> <a href="/tags/%E5%8D%8F%E4%BD%9C/" style="font-size: 15px;">协作</a> <a href="/tags/%E8%BD%AF%E7%B4%A0%E8%B4%A8/" style="font-size: 15px;">软素质</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/" style="font-size: 15px;">分布式技术</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/consensus-algorithm/" style="font-size: 15px;">consensus algorithm</a> <a href="/tags/zab/" style="font-size: 15px;">zab</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE/" style="font-size: 15px;">分布式协议</a> <a href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/" style="font-size: 15px;">一致性算法</a> <a href="/tags/%E6%96%B9%E6%B3%95%E8%AE%BA-%E8%BD%AF%E7%B4%A0%E8%B4%A8%E6%8F%90%E5%8D%87/" style="font-size: 15px;">方法论 软素质提升</a> <a href="/tags/kafka-netty-%E6%97%B6%E9%97%B4%E8%BD%AE/" style="font-size: 15px;">kafka netty 时间轮</a> <a href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" style="font-size: 15px;">云原生</a> <a href="/tags/%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97/" style="font-size: 15px;">流式计算</a> <a href="/tags/%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E4%BC%98%E5%8C%96/" style="font-size: 15px;">磁盘读写优化</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/06/18/Rewriting-Kafka-in-Rust-Async-Insights-and-Lessons-Learned/">Rewriting Kafka in Rust Async: Insights and Lessons Learned in Rust</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/10/Announcing-Stonemq-A-high-performance-and-efficient-message-queue-developed-in-Rust/">Announcing Stonemq: A high-performance and efficient message queue developed in Rust</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/12/25/Apache-Pulsar%E7%9A%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/">Apache Pulsar的存储模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/09/15/Apache-pulsar%E5%AF%B9zookeeper%E7%9A%84%E4%BE%9D%E8%B5%96%E5%92%8C%E5%8E%BB%E9%99%A4%E5%88%86%E6%9E%90-%E4%BA%8C/">Apache pulsar对zookeeper的依赖和去除分析(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/06/15/Apache-pulsar%E5%AF%B9zookeeper%E7%9A%84%E4%BE%9D%E8%B5%96%E5%92%8C%E5%8E%BB%E9%99%A4%E5%88%86%E6%9E%90-%E4%B8%80/">Apache pulsar对zookeeper的依赖和去除分析(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/10/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E7%94%A8/">时间轮算法分析和应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/01/Kafka%E5%8E%BBZookeeper%E6%8F%AD%E7%A7%98/">Kafka去Zookeeper揭秘</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/09/15/PRFAQ%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/">「转」PRFAQ编写规范</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/09/13/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95%E8%AE%BA%E6%B1%87%E9%9B%86/">「转」几种常见的工作方法论汇集</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/14/%E8%BD%AF%E7%B4%A0%E8%B4%A8%E8%9E%BA%E6%97%8B%E4%B8%8A%E5%8D%87/">软素质螺旋上升</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Rex Wang.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>